
export enum UserTier {
  FREE = 'FREE',
  PREMIUM = 'PREMIUM'
}

export interface User {
  id: string;
  name: string;
  email: string;
  tier: UserTier;
  coins: number;
}

export enum TranslationMode {
  VOICE_TO_VOICE = 'VOICE_TO_VOICE',
  VOICE_TO_TEXT = 'VOICE_TO_TEXT',
  TEXT_TO_TEXT = 'TEXT_TO_TEXT',
  IMAGE_TO_TEXT = 'IMAGE_TO_TEXT'
}

export interface Device {
  id: string;
  name: string;
  connected: boolean;
  batteryLevel: number;
  type: 'GLASSES_BASIC' | 'GLASSES_AI' | 'WATCH' | 'AUDIO' | 'ROBOT';
  firmwareVersion: string;
  image?: string;
}

export interface ChatMessage {
  id: string;
  role: 'user' | 'model';
  text: string;
  timestamp: number;
  attachment?: string; // Base64 image string
  feedback?: 'like' | 'dislike' | null;
}

export interface Product {
  id: string;
  name: string;
  price: number;
  description: string;
  image: string;
  features: string[];
  category: 'Glasses' | 'Watch' | 'Audio' | 'Robot' | 'Accessory';
  rating: number;
  reviews: number;
  isNew?: boolean;
  isFeatured?: boolean;
}

export type MediaType = 'image' | 'video' | 'audio';

export interface MediaItem {
  id: string;
  type: MediaType;
  url: string;
  timestamp: number;
  location?: string;
  aiDescription?: string; // Metadata generated by glasses AI
  isDownloaded?: boolean; // Local cache flag
}

export interface RobotTheme {
  id: string;
  name: string;
  previewUrl: string;
  isPremium: boolean;
}

export type RobotRoleType = 'DOCTOR' | 'TUTOR' | 'ENTERTAINER' | 'RADIO';

// --- Vision AI Types ---

export interface VisionResult {
  description: string;
  detectedObjects: string[];
  ocrText: string | null;
  confidence: number;
}

export interface TranslationMessage {
    id: string;
    speaker: 'A' | 'B';
    originalText: string;
    translatedText: string;
    timestamp: number;
    language: string;
}

// --- Simultaneous Translation Types ---

export interface TranscriptSegment {
    id: string;
    text: string;
    isFinal: boolean;
    timestamp: number;
}

export interface TranslationSession {
  id: string;
  startTime: number;
  endTime: number;
  sourceLang: string;
  targetLang: string;
  sourceTranscript: TranscriptSegment[];
  translatedTranscript: {id: string, text: string}[];
  audioPath?: string; // Mock local path
}

export interface IAIGateway {
  analyzeImage(file: File): Promise<VisionResult>;
  sttOnce(audio: Blob): Promise<string>;
  translate(text: string, sourceLang: string, targetLang: string): Promise<string>;
  chatStream(history: ChatMessage[], newMessage: string, image?: string): AsyncGenerator<string>;
}

// --- Gesture Control Types ---

export type GestureType = 'TAP' | 'DOUBLE_TAP' | 'SWIPE_FORWARD' | 'SWIPE_BACKWARD' | 'HOLD';
export type ActionType = 'NONE' | 'PLAY_PAUSE' | 'NEXT_TRACK' | 'PREV_TRACK' | 'VOL_UP' | 'VOL_DOWN' | 'ASSISTANT' | 'TAKE_PHOTO';

export interface GestureMap {
    TAP: ActionType;
    DOUBLE_TAP: ActionType;
    SWIPE_FORWARD: ActionType;
    SWIPE_BACKWARD: ActionType;
    HOLD: ActionType;
}

// --- Firmware Types ---

export type FirmwareStage = 'IDLE' | 'DOWNLOADING' | 'FLASHING' | 'VERIFYING' | 'COMPLETE' | 'FAILED';

export interface FirmwareProgress {
    stage: FirmwareStage;
    progress: number; // 0-100
    message?: string;
}

// --- Device Service Abstraction ---

export interface IDeviceService {
  // Connection
  connect(deviceId: string): Promise<boolean>;
  disconnect(): Promise<void>;
  
  // State
  getBatteryLevel(): Promise<number>;
  get status(): 'DISCONNECTED' | 'SCANNING' | 'CONNECTING' | 'CONNECTED';
  get deviceInfo(): Device | null;
  
  // Camera Control
  capturePhoto(): Promise<boolean>;
  startVideoRecording(): Promise<boolean>;
  stopVideoRecording(): Promise<boolean>;
  
  // Audio Control
  startAudioRecording(): Promise<boolean>;
  stopAudioRecording(): Promise<boolean>;
  
  // Media Management
  listMediaFiles(): Promise<MediaItem[]>;
  downloadMediaFile(fileId: string): Promise<string>; // Returns local URL or Base64
  
  // Settings
  updateSettings(settings: any): void;
  updateFirmware(file?: File): Promise<void>;
  setGestureMapping(mapping: GestureMap): Promise<boolean>;

  // Events
  subscribe(event: string, callback: (data: any) => void): () => void;
}
